This would help to ensure that the code would not change (possibly maliciously) in the future. This is useful for when code is distributed on mailing lists.From the user's perspective, they can know that if they've run the code in the past and it worked fine, that they'll get the same code, and so there aren't any malicious changes. It also would be be useful for establishing "social trust" of a gist: in a public setting like a mailing list, if the remotely hosted code is vetted by users and there's no complaints, then others can trust that the code isn't malicious, because it's impossible to change the code without detection.For example, if I'm a reader on the shiny-discuss mailing list, I might be apprehensive about simply blindly running `runGist()`, but if the code has a SHA, and people that I trust have been discussing the code, then I can feel safer about running it without examining the code.The author would distribute this information, which the users would run:```rrunGist(12345678, sha='0123456789abcdef')````If `runGist` were called without `sha`, it would prompt the user about the risks, and ask them if they're sure they want to continue. (The prompt could be disabled with `prompt=FALSE`.)From the author's perspective, they would first push changes to gist.github.com, then run the following to find the SHA:```shaGist(0123456789)# SHA: 0123456789abcdef# Command to run: runGist(12345678, sha='0123456789abcdef')```If the author wants to change the gist, then they will have to distribute a new SHA (or the users can run with the prompt).It would be nice to also be able to download and run a specific commit in a gist, so that if changes are made to the Gist, the user can still use `runGist` on the original commit.If the author distributes the SHA, then they don't need to worry about securing the remote server that hosts the code.
